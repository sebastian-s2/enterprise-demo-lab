# Copyright (c) 2024 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: arista/tag.v1/services.gen.proto, arista/tag.v1/tag.proto
# plugin: python-aristaproto
# This file has been @generated

from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    AsyncIterator,
    Dict,
    List,
    Optional,
)

try:
    import aristaproto
    import grpclib
    from aristaproto.grpc.grpclib_server import ServiceBase
except ImportError:
    HAS_ARISTAPROTO = False
    from ansible_collections.arista.avd.plugins.plugin_utils.cv_client.mocked_classes import mocked_aristaproto as aristaproto
    from ansible_collections.arista.avd.plugins.plugin_utils.cv_client.mocked_classes import mocked_grpclib as grpclib
    ServiceBase = object
else:
    HAS_ARISTAPROTO = True

from .... import fmp as ___fmp__
from ... import (
    subscriptions as __subscriptions__,
    time as __time__,
)


if TYPE_CHECKING:
    import grpclib.server
    from aristaproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class CreatorType(aristaproto.Enum):
    """CreatorType specifies an entity that creates something."""

    UNSPECIFIED = 0
    SYSTEM = 1
    """CREATOR_TYPE_SYSTEM is the type for something created by the system."""

    USER = 2
    """CREATOR_TYPE_USER is the type for something created by a user."""


@dataclass(eq=False, repr=False)
class TagKey(aristaproto.Message):
    """TagKey uniquely identifies a tag for a network element."""

    label: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """Label is the label of the tag."""

    value: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """Value is the value of the tag."""


@dataclass(eq=False, repr=False)
class InterfaceTagConfig(aristaproto.Message):
    """
    InterfaceTagConfig is a label-value pair that may or may
     not be assigned to an interface.
    """

    key: "TagKey" = aristaproto.message_field(1)
    """Key uniquely identifies the interface tag."""


@dataclass(eq=False, repr=False)
class InterfaceTag(aristaproto.Message):
    """
    InterfaceTag is a label-value pair that may or may
     not be assigned to an interface.
    """

    key: "TagKey" = aristaproto.message_field(1)
    """Key uniquely identifies the interface tag."""

    creator_type: "CreatorType" = aristaproto.enum_field(2)
    """CreatorType is the creator type of the tag."""


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentKey(aristaproto.Message):
    """
    InterfaceTagAssignmentKey uniquely identifies an interface
     tag assignment.
    """

    label: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """Label is the label of the tag."""

    value: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """Value is the value of the tag."""

    device_id: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """DeviceId is the ID of the interface's device."""

    interface_id: Optional[str] = aristaproto.message_field(
        4, wraps=aristaproto.TYPE_STRING
    )
    """InterfaceId is the ID of the interface."""


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfig(aristaproto.Message):
    """
    InterfaceTagAssignmentConfig is the assignment of an interface tag
     to a specific interface.
    """

    key: "InterfaceTagAssignmentKey" = aristaproto.message_field(1)
    """Key uniquely identifies the interface tag assignment."""


@dataclass(eq=False, repr=False)
class DeviceTagConfig(aristaproto.Message):
    """
    DeviceTagConfig is a label-value pair that may or may not
     be assigned to a device.
    """

    key: "TagKey" = aristaproto.message_field(1)
    """Key uniquely identifies the device tag."""


@dataclass(eq=False, repr=False)
class DeviceTag(aristaproto.Message):
    """
    DeviceTag is a label-value pair that may or may not
     be assigned to a device.
    """

    key: "TagKey" = aristaproto.message_field(1)
    """Key uniquely identifies the device tag."""

    creator_type: "CreatorType" = aristaproto.enum_field(2)
    """CreatorType is the creator type of the tag."""


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentKey(aristaproto.Message):
    """
    DeviceTagAssignmentKey uniquely identifies a device tag
     assignment.
    """

    label: Optional[str] = aristaproto.message_field(1, wraps=aristaproto.TYPE_STRING)
    """Label is the label of the tag."""

    value: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """Value is the value of the tag."""

    device_id: Optional[str] = aristaproto.message_field(
        3, wraps=aristaproto.TYPE_STRING
    )
    """DeviceId is the ID of the device."""


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfig(aristaproto.Message):
    """
    DeviceTagAssignmentConfig is the assignment of a device tag to a
     specific device.
    """

    key: "DeviceTagAssignmentKey" = aristaproto.message_field(1)
    """Key uniquely identifies the device tag assignment."""


@dataclass(eq=False, repr=False)
class DeviceTagRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceTag instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceTagResponse(aristaproto.Message):
    value: "DeviceTag" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceTag instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceTagStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceTag"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceTagStreamResponse(aristaproto.Message):
    value: "DeviceTag" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this DeviceTag's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceTag value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigRequest(aristaproto.Message):
    key: "DeviceTagAssignmentKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceTagAssignmentConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigResponse(aristaproto.Message):
    value: "DeviceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceTagAssignmentConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceTagAssignmentConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigStreamResponse(aristaproto.Message):
    value: "DeviceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceTagAssignmentConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceTagAssignmentConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigSetRequest(aristaproto.Message):
    value: "DeviceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    DeviceTagAssignmentConfig carries the value to set into the datastore.
     See the documentation on the DeviceTagAssignmentConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigSetResponse(aristaproto.Message):
    value: "DeviceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DeviceTagAssignmentConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteRequest(aristaproto.Message):
    key: "DeviceTagAssignmentKey" = aristaproto.message_field(1)
    """
    Key indicates which DeviceTagAssignmentConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteResponse(aristaproto.Message):
    key: "DeviceTagAssignmentKey" = aristaproto.message_field(1)
    """
    Key echoes back the key of the deleted DeviceTagAssignmentConfig instance.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteAllRequest(aristaproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeviceTagAssignmentConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "DeviceTagAssignmentKey" = aristaproto.message_field(3)
    """
    This is the key of the DeviceTagAssignmentConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class DeviceTagConfigRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a DeviceTagConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigResponse(aristaproto.Message):
    value: "DeviceTagConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     DeviceTagConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["DeviceTagConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigStreamResponse(aristaproto.Message):
    value: "DeviceTagConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this DeviceTagConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the DeviceTagConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigSetRequest(aristaproto.Message):
    value: "DeviceTagConfig" = aristaproto.message_field(1)
    """
    DeviceTagConfig carries the value to set into the datastore.
     See the documentation on the DeviceTagConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigSetResponse(aristaproto.Message):
    value: "DeviceTagConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the DeviceTagConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key indicates which DeviceTagConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteResponse(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted DeviceTagConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteAllRequest(aristaproto.Message):
    pass


@dataclass(eq=False, repr=False)
class DeviceTagConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TagKey" = aristaproto.message_field(3)
    """
    This is the key of the DeviceTagConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class InterfaceTagRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a InterfaceTag instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagResponse(aristaproto.Message):
    value: "InterfaceTag" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     InterfaceTag instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagStreamRequest(aristaproto.Message):
    partial_eq_filter: List["InterfaceTag"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagStreamResponse(aristaproto.Message):
    value: "InterfaceTag" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """Time holds the timestamp of this InterfaceTag's last modification."""

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the InterfaceTag value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigRequest(aristaproto.Message):
    key: "InterfaceTagAssignmentKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a InterfaceTagAssignmentConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigResponse(aristaproto.Message):
    value: "InterfaceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     InterfaceTagAssignmentConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["InterfaceTagAssignmentConfig"] = aristaproto.message_field(
        1
    )
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigStreamResponse(aristaproto.Message):
    value: "InterfaceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this InterfaceTagAssignmentConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the InterfaceTagAssignmentConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigSetRequest(aristaproto.Message):
    value: "InterfaceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    InterfaceTagAssignmentConfig carries the value to set into the datastore.
     See the documentation on the InterfaceTagAssignmentConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigSetResponse(aristaproto.Message):
    value: "InterfaceTagAssignmentConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the InterfaceTagAssignmentConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteRequest(aristaproto.Message):
    key: "InterfaceTagAssignmentKey" = aristaproto.message_field(1)
    """
    Key indicates which InterfaceTagAssignmentConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteResponse(aristaproto.Message):
    key: "InterfaceTagAssignmentKey" = aristaproto.message_field(1)
    """
    Key echoes back the key of the deleted InterfaceTagAssignmentConfig instance.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteAllRequest(aristaproto.Message):
    pass


@dataclass(eq=False, repr=False)
class InterfaceTagAssignmentConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "InterfaceTagAssignmentKey" = aristaproto.message_field(3)
    """
    This is the key of the InterfaceTagAssignmentConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


@dataclass(eq=False, repr=False)
class InterfaceTagConfigRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key uniquely identifies a InterfaceTagConfig instance to retrieve.
     This value must be populated.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the time for which you are interested in the data.
     If no time is given, the server will use the time at which it makes the request.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigResponse(aristaproto.Message):
    value: "InterfaceTagConfig" = aristaproto.message_field(1)
    """
    Value is the value requested.
     This structure will be fully-populated as it exists in the datastore. If
     optional fields were not given at creation, these fields will be empty or
     set to default values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time carries the (UTC) timestamp of the last-modification of the
     InterfaceTagConfig instance in this response.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigStreamRequest(aristaproto.Message):
    partial_eq_filter: List["InterfaceTagConfig"] = aristaproto.message_field(1)
    """
    PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.
     This requires all provided fields to be equal to the response.

     While transparent to users, this field also allows services to optimize internal
     subscriptions if filter(s) are sufficiently specific.
    """

    time: "__time__.TimeBounds" = aristaproto.message_field(3)
    """
    TimeRange allows limiting response data to within a specified time window.
     If this field is populated, at least one of the two time fields are required.

     This field is not allowed in the Subscribe RPC.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigStreamResponse(aristaproto.Message):
    value: "InterfaceTagConfig" = aristaproto.message_field(1)
    """
    Value is a value deemed relevant to the initiating request.
     This structure will always have its key-field populated. Which other fields are
     populated, and why, depends on the value of Operation and what triggered this notification.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time holds the timestamp of this InterfaceTagConfig's last modification.
    """

    type: "__subscriptions__.Operation" = aristaproto.enum_field(3)
    """
    Operation indicates how the InterfaceTagConfig value in this response should be considered.
     Under non-subscribe requests, this value should always be INITIAL. In a subscription,
     once all initial data is streamed and the client begins to receive modification updates,
     you should not see INITIAL again.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigSetRequest(aristaproto.Message):
    value: "InterfaceTagConfig" = aristaproto.message_field(1)
    """
    InterfaceTagConfig carries the value to set into the datastore.
     See the documentation on the InterfaceTagConfig struct for which fields are required.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigSetResponse(aristaproto.Message):
    value: "InterfaceTagConfig" = aristaproto.message_field(1)
    """
    Value carries all the values given in the InterfaceTagConfigSetRequest as well
     as any server-generated values.
    """

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     creation. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==CreatedAt will include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteRequest(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """
    Key indicates which InterfaceTagConfig instance to remove.
     This field must always be set.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteResponse(aristaproto.Message):
    key: "TagKey" = aristaproto.message_field(1)
    """Key echoes back the key of the deleted InterfaceTagConfig instance."""

    time: datetime = aristaproto.message_field(2)
    """
    Time indicates the (UTC) timestamp at which the system recognizes the
     deletion. The only guarantees made about this timestamp are:

        - it is after the time the request was received
        - a time-ranged query with StartTime==DeletedAt will not include this instance.
    """


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteAllRequest(aristaproto.Message):
    pass


@dataclass(eq=False, repr=False)
class InterfaceTagConfigDeleteAllResponse(aristaproto.Message):
    type: "___fmp__.DeleteError" = aristaproto.enum_field(1)
    """This describes the class of delete error."""

    error: Optional[str] = aristaproto.message_field(2, wraps=aristaproto.TYPE_STRING)
    """This indicates the error message from the delete failure."""

    key: "TagKey" = aristaproto.message_field(3)
    """
    This is the key of the InterfaceTagConfig instance that failed to be deleted.
    """

    time: datetime = aristaproto.message_field(4)
    """Time indicates the (UTC) timestamp when the key was being deleted."""


class DeviceTagServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_tag_request: "DeviceTagRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagService/GetOne",
            device_tag_request,
            DeviceTagResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_tag_stream_request: "DeviceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagService/GetAll",
            device_tag_stream_request,
            DeviceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_tag_stream_request: "DeviceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagService/Subscribe",
            device_tag_stream_request,
            DeviceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceTagAssignmentConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_tag_assignment_config_request: "DeviceTagAssignmentConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagAssignmentConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetOne",
            device_tag_assignment_config_request,
            DeviceTagAssignmentConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetAll",
            device_tag_assignment_config_stream_request,
            DeviceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Subscribe",
            device_tag_assignment_config_stream_request,
            DeviceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_tag_assignment_config_set_request: "DeviceTagAssignmentConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagAssignmentConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Set",
            device_tag_assignment_config_set_request,
            DeviceTagAssignmentConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        device_tag_assignment_config_delete_request: "DeviceTagAssignmentConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagAssignmentConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Delete",
            device_tag_assignment_config_delete_request,
            DeviceTagAssignmentConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        device_tag_assignment_config_delete_all_request: "DeviceTagAssignmentConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagAssignmentConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagAssignmentConfigService/DeleteAll",
            device_tag_assignment_config_delete_all_request,
            DeviceTagAssignmentConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceTagConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        device_tag_config_request: "DeviceTagConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagConfigService/GetOne",
            device_tag_config_request,
            DeviceTagConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        device_tag_config_stream_request: "DeviceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagConfigService/GetAll",
            device_tag_config_stream_request,
            DeviceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        device_tag_config_stream_request: "DeviceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagConfigService/Subscribe",
            device_tag_config_stream_request,
            DeviceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        device_tag_config_set_request: "DeviceTagConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagConfigService/Set",
            device_tag_config_set_request,
            DeviceTagConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        device_tag_config_delete_request: "DeviceTagConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeviceTagConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.DeviceTagConfigService/Delete",
            device_tag_config_delete_request,
            DeviceTagConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        device_tag_config_delete_all_request: "DeviceTagConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DeviceTagConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.DeviceTagConfigService/DeleteAll",
            device_tag_config_delete_all_request,
            DeviceTagConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceTagServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        interface_tag_request: "InterfaceTagRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagService/GetOne",
            interface_tag_request,
            InterfaceTagResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        interface_tag_stream_request: "InterfaceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagService/GetAll",
            interface_tag_stream_request,
            InterfaceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_tag_stream_request: "InterfaceTagStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagService/Subscribe",
            interface_tag_stream_request,
            InterfaceTagStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceTagAssignmentConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        interface_tag_assignment_config_request: "InterfaceTagAssignmentConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagAssignmentConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetOne",
            interface_tag_assignment_config_request,
            InterfaceTagAssignmentConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetAll",
            interface_tag_assignment_config_stream_request,
            InterfaceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Subscribe",
            interface_tag_assignment_config_stream_request,
            InterfaceTagAssignmentConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        interface_tag_assignment_config_set_request: "InterfaceTagAssignmentConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagAssignmentConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Set",
            interface_tag_assignment_config_set_request,
            InterfaceTagAssignmentConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        interface_tag_assignment_config_delete_request: "InterfaceTagAssignmentConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagAssignmentConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Delete",
            interface_tag_assignment_config_delete_request,
            InterfaceTagAssignmentConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        interface_tag_assignment_config_delete_all_request: "InterfaceTagAssignmentConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagAssignmentConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/DeleteAll",
            interface_tag_assignment_config_delete_all_request,
            InterfaceTagAssignmentConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class InterfaceTagConfigServiceStub(aristaproto.ServiceStub):
    async def get_one(
        self,
        interface_tag_config_request: "InterfaceTagConfigRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagConfigResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagConfigService/GetOne",
            interface_tag_config_request,
            InterfaceTagConfigResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_all(
        self,
        interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagConfigService/GetAll",
            interface_tag_config_stream_request,
            InterfaceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def subscribe(
        self,
        interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagConfigService/Subscribe",
            interface_tag_config_stream_request,
            InterfaceTagConfigStreamResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def set(
        self,
        interface_tag_config_set_request: "InterfaceTagConfigSetRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagConfigSetResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagConfigService/Set",
            interface_tag_config_set_request,
            InterfaceTagConfigSetResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete(
        self,
        interface_tag_config_delete_request: "InterfaceTagConfigDeleteRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InterfaceTagConfigDeleteResponse":
        return await self._unary_unary(
            "/arista.tag.v1.InterfaceTagConfigService/Delete",
            interface_tag_config_delete_request,
            InterfaceTagConfigDeleteResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_all(
        self,
        interface_tag_config_delete_all_request: "InterfaceTagConfigDeleteAllRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InterfaceTagConfigDeleteAllResponse"]:
        async for response in self._unary_stream(
            "/arista.tag.v1.InterfaceTagConfigService/DeleteAll",
            interface_tag_config_delete_all_request,
            InterfaceTagConfigDeleteAllResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class DeviceTagServiceBase(ServiceBase):

    async def get_one(
        self, device_tag_request: "DeviceTagRequest"
    ) -> "DeviceTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_tag_stream_request: "DeviceTagStreamRequest"
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_tag_stream_request: "DeviceTagStreamRequest"
    ) -> AsyncIterator["DeviceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[DeviceTagRequest, DeviceTagResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagStreamRequest, DeviceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceTagStreamRequest, DeviceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.DeviceTagService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagRequest,
                DeviceTagResponse,
            ),
            "/arista.tag.v1.DeviceTagService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagStreamRequest,
                DeviceTagStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagStreamRequest,
                DeviceTagStreamResponse,
            ),
        }


class DeviceTagAssignmentConfigServiceBase(ServiceBase):

    async def get_one(
        self, device_tag_assignment_config_request: "DeviceTagAssignmentConfigRequest"
    ) -> "DeviceTagAssignmentConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self,
        device_tag_assignment_config_stream_request: "DeviceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["DeviceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self,
        device_tag_assignment_config_set_request: "DeviceTagAssignmentConfigSetRequest",
    ) -> "DeviceTagAssignmentConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        device_tag_assignment_config_delete_request: "DeviceTagAssignmentConfigDeleteRequest",
    ) -> "DeviceTagAssignmentConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        device_tag_assignment_config_delete_all_request: "DeviceTagAssignmentConfigDeleteAllRequest",
    ) -> AsyncIterator["DeviceTagAssignmentConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigRequest, DeviceTagAssignmentConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigStreamRequest, DeviceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigStreamRequest, DeviceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigSetRequest, DeviceTagAssignmentConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigDeleteRequest, DeviceTagAssignmentConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagAssignmentConfigDeleteAllRequest, DeviceTagAssignmentConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagAssignmentConfigRequest,
                DeviceTagAssignmentConfigResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagAssignmentConfigStreamRequest,
                DeviceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagAssignmentConfigStreamRequest,
                DeviceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagAssignmentConfigSetRequest,
                DeviceTagAssignmentConfigSetResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagAssignmentConfigDeleteRequest,
                DeviceTagAssignmentConfigDeleteResponse,
            ),
            "/arista.tag.v1.DeviceTagAssignmentConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagAssignmentConfigDeleteAllRequest,
                DeviceTagAssignmentConfigDeleteAllResponse,
            ),
        }


class DeviceTagConfigServiceBase(ServiceBase):

    async def get_one(
        self, device_tag_config_request: "DeviceTagConfigRequest"
    ) -> "DeviceTagConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, device_tag_config_stream_request: "DeviceTagConfigStreamRequest"
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, device_tag_config_stream_request: "DeviceTagConfigStreamRequest"
    ) -> AsyncIterator["DeviceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, device_tag_config_set_request: "DeviceTagConfigSetRequest"
    ) -> "DeviceTagConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, device_tag_config_delete_request: "DeviceTagConfigDeleteRequest"
    ) -> "DeviceTagConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self, device_tag_config_delete_all_request: "DeviceTagConfigDeleteAllRequest"
    ) -> AsyncIterator["DeviceTagConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigRequest, DeviceTagConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigStreamRequest, DeviceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigStreamRequest, DeviceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigSetRequest, DeviceTagConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigDeleteRequest, DeviceTagConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[DeviceTagConfigDeleteAllRequest, DeviceTagConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.DeviceTagConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagConfigRequest,
                DeviceTagConfigResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagConfigStreamRequest,
                DeviceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagConfigStreamRequest,
                DeviceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagConfigSetRequest,
                DeviceTagConfigSetResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeviceTagConfigDeleteRequest,
                DeviceTagConfigDeleteResponse,
            ),
            "/arista.tag.v1.DeviceTagConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                DeviceTagConfigDeleteAllRequest,
                DeviceTagConfigDeleteAllResponse,
            ),
        }


class InterfaceTagServiceBase(ServiceBase):

    async def get_one(
        self, interface_tag_request: "InterfaceTagRequest"
    ) -> "InterfaceTagResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, interface_tag_stream_request: "InterfaceTagStreamRequest"
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, interface_tag_stream_request: "InterfaceTagStreamRequest"
    ) -> AsyncIterator["InterfaceTagStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self, stream: "grpclib.server.Stream[InterfaceTagRequest, InterfaceTagResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagStreamRequest, InterfaceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceTagStreamRequest, InterfaceTagStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.InterfaceTagService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagRequest,
                InterfaceTagResponse,
            ),
            "/arista.tag.v1.InterfaceTagService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagStreamRequest,
                InterfaceTagStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagStreamRequest,
                InterfaceTagStreamResponse,
            ),
        }


class InterfaceTagAssignmentConfigServiceBase(ServiceBase):

    async def get_one(
        self,
        interface_tag_assignment_config_request: "InterfaceTagAssignmentConfigRequest",
    ) -> "InterfaceTagAssignmentConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self,
        interface_tag_assignment_config_stream_request: "InterfaceTagAssignmentConfigStreamRequest",
    ) -> AsyncIterator["InterfaceTagAssignmentConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self,
        interface_tag_assignment_config_set_request: "InterfaceTagAssignmentConfigSetRequest",
    ) -> "InterfaceTagAssignmentConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self,
        interface_tag_assignment_config_delete_request: "InterfaceTagAssignmentConfigDeleteRequest",
    ) -> "InterfaceTagAssignmentConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        interface_tag_assignment_config_delete_all_request: "InterfaceTagAssignmentConfigDeleteAllRequest",
    ) -> AsyncIterator["InterfaceTagAssignmentConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigRequest, InterfaceTagAssignmentConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigStreamRequest, InterfaceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigStreamRequest, InterfaceTagAssignmentConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigSetRequest, InterfaceTagAssignmentConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigDeleteRequest, InterfaceTagAssignmentConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagAssignmentConfigDeleteAllRequest, InterfaceTagAssignmentConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagAssignmentConfigRequest,
                InterfaceTagAssignmentConfigResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagAssignmentConfigStreamRequest,
                InterfaceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagAssignmentConfigStreamRequest,
                InterfaceTagAssignmentConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagAssignmentConfigSetRequest,
                InterfaceTagAssignmentConfigSetResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagAssignmentConfigDeleteRequest,
                InterfaceTagAssignmentConfigDeleteResponse,
            ),
            "/arista.tag.v1.InterfaceTagAssignmentConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagAssignmentConfigDeleteAllRequest,
                InterfaceTagAssignmentConfigDeleteAllResponse,
            ),
        }


class InterfaceTagConfigServiceBase(ServiceBase):

    async def get_one(
        self, interface_tag_config_request: "InterfaceTagConfigRequest"
    ) -> "InterfaceTagConfigResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_all(
        self, interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest"
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def subscribe(
        self, interface_tag_config_stream_request: "InterfaceTagConfigStreamRequest"
    ) -> AsyncIterator["InterfaceTagConfigStreamResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def set(
        self, interface_tag_config_set_request: "InterfaceTagConfigSetRequest"
    ) -> "InterfaceTagConfigSetResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete(
        self, interface_tag_config_delete_request: "InterfaceTagConfigDeleteRequest"
    ) -> "InterfaceTagConfigDeleteResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_all(
        self,
        interface_tag_config_delete_all_request: "InterfaceTagConfigDeleteAllRequest",
    ) -> AsyncIterator["InterfaceTagConfigDeleteAllResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_one(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigRequest, InterfaceTagConfigResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_one(request)
        await stream.send_message(response)

    async def __rpc_get_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigStreamRequest, InterfaceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_all,
            stream,
            request,
        )

    async def __rpc_subscribe(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigStreamRequest, InterfaceTagConfigStreamResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe,
            stream,
            request,
        )

    async def __rpc_set(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigSetRequest, InterfaceTagConfigSetResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.set(request)
        await stream.send_message(response)

    async def __rpc_delete(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigDeleteRequest, InterfaceTagConfigDeleteResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete(request)
        await stream.send_message(response)

    async def __rpc_delete_all(
        self,
        stream: "grpclib.server.Stream[InterfaceTagConfigDeleteAllRequest, InterfaceTagConfigDeleteAllResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.delete_all,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/arista.tag.v1.InterfaceTagConfigService/GetOne": grpclib.const.Handler(
                self.__rpc_get_one,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagConfigRequest,
                InterfaceTagConfigResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/GetAll": grpclib.const.Handler(
                self.__rpc_get_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagConfigStreamRequest,
                InterfaceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/Subscribe": grpclib.const.Handler(
                self.__rpc_subscribe,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagConfigStreamRequest,
                InterfaceTagConfigStreamResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/Set": grpclib.const.Handler(
                self.__rpc_set,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagConfigSetRequest,
                InterfaceTagConfigSetResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/Delete": grpclib.const.Handler(
                self.__rpc_delete,
                grpclib.const.Cardinality.UNARY_UNARY,
                InterfaceTagConfigDeleteRequest,
                InterfaceTagConfigDeleteResponse,
            ),
            "/arista.tag.v1.InterfaceTagConfigService/DeleteAll": grpclib.const.Handler(
                self.__rpc_delete_all,
                grpclib.const.Cardinality.UNARY_STREAM,
                InterfaceTagConfigDeleteAllRequest,
                InterfaceTagConfigDeleteAllResponse,
            ),
        }
